<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java," />








  <link rel="shortcut icon" type="image/x-icon" href="/uploads/favicon.ico?v=5.1.1" />






<meta name="description" content="Java 封装封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。 封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。  实现Java封装的步骤 修改属性的可见性来限制对属性的访问（一般限制为private），对信息进行了隐藏。 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="java oop">
<meta property="og:url" content="http://yoursite.com/2017/09/18/java-oop/index.html">
<meta property="og:site_name" content="离离原上草">
<meta property="og:description" content="Java 封装封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。 封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。  实现Java封装的步骤 修改属性的可见性来限制对属性的访问（一般限制为private），对信息进行了隐藏。 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-10-13T07:58:21.479Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java oop">
<meta name="twitter:description" content="Java 封装封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。 封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。  实现Java封装的步骤 修改属性的可见性来限制对属性的访问（一般限制为private），对信息进行了隐藏。 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '2826EPHU2B',
      apiKey: 'f88bfd768a4b086dc17a7c4946499618',
      indexName: '26fdb1447b8c93b980ce075eb0d6b7e9',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/18/java-oop/"/>





  <title>java oop | 离离原上草</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?eee29daecf3c11799e28ab5768869fee";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">离离原上草</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/18/java-oop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="徐宏亮">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="离离原上草">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java oop</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-18T14:10:37+08:00">
                2017-09-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java-封装"><a href="#Java-封装" class="headerlink" title="Java 封装"></a>Java 封装</h1><p>封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</p>
<h2 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h2><ol>
<li>良好的封装能够减少耦合。</li>
<li>类内部的结构可以自由修改。</li>
<li>可以对成员变量进行更精确的控制。</li>
<li>隐藏信息，实现细节。</li>
</ol>
<h2 id="实现Java封装的步骤"><a href="#实现Java封装的步骤" class="headerlink" title="实现Java封装的步骤"></a>实现Java封装的步骤</h2><ol>
<li>修改属性的可见性来限制对属性的访问（一般限制为private），对信息进行了隐藏。</li>
<li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问（set,get方法）。</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncapTest</span></span>&#123;</div><div class="line"> </div><div class="line">   <span class="keyword">private</span> <span class="keyword">String</span> name;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">String</span> idNum;</div><div class="line">   <span class="keyword">private</span> int age;</div><div class="line"> </div><div class="line">   <span class="keyword">public</span> int getAge()&#123;</div><div class="line">      <span class="keyword">return</span> age;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="keyword">public</span> <span class="keyword">String</span> getName()&#123;</div><div class="line">      <span class="keyword">return</span> name;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="keyword">public</span> <span class="keyword">String</span> getIdNum()&#123;</div><div class="line">      <span class="keyword">return</span> idNum;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="keyword">public</span> void setAge( int <span class="keyword">new</span><span class="type">Age</span>)&#123;</div><div class="line">      age = <span class="keyword">new</span><span class="type">Age</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="keyword">public</span> void setName(<span class="keyword">String</span> <span class="keyword">new</span><span class="type">Name</span>)&#123;</div><div class="line">      name = <span class="keyword">new</span><span class="type">Name</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="keyword">public</span> void setIdNum( <span class="keyword">String</span> <span class="keyword">new</span><span class="type">Id</span>)&#123;</div><div class="line">      idNum = <span class="keyword">new</span><span class="type">Id</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实例中public方法是外部类访问该类成员变量的入口，这些方法被称为getter和setter方法。任何要访问类中私有成员变量的类都要通过这些getter和setter方法。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RunEncap</span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span>&#123;</div><div class="line">      EncapTest encap = <span class="keyword">new</span> EncapTest();</div><div class="line">      encap.setName(<span class="string">"James"</span>);</div><div class="line">      encap.setAge(<span class="number">20</span>);</div><div class="line">      encap.setIdNum(<span class="string">"12343ms"</span>);</div><div class="line"> </div><div class="line">      System.<span class="keyword">out</span>.print(<span class="string">"Name : "</span> + encap.getName() + <span class="string">" Age : "</span> + encap.getAge());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Name : James Age : <span class="number">20</span></div></pre></td></tr></table></figure></p>
<h1 id="Java-继承"><a href="#Java-继承" class="headerlink" title="Java 继承"></a>Java 继承</h1><h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<h3 id="生活中的继承"><a href="#生活中的继承" class="headerlink" title="生活中的继承"></a>生活中的继承</h3><p>兔子和羊属于食草动物类，狮子和豹属于食肉动物类。<br>食草动物和食肉动物又是属于动物类。</p>
<p>虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。</p>
<h3 id="类的继承格式"><a href="#类的继承格式" class="headerlink" title="类的继承格式"></a>类的继承格式</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">父类</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">子类</span> <span class="keyword">extends</span> <span class="title">父类</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="为什么需要继承"><a href="#为什么需要继承" class="headerlink" title="为什么需要继承"></a>为什么需要继承</h3><p>当有两个类的代码存在重复，导致后果就是代码量大且臃肿，而且维护性不高，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成一个父类。</p>
<h2 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h2><ul>
<li>子类拥有父类非private的属性和方法。</li>
<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
<li>Java的继承是单继承（一个子类只能继承一个父类），但是可以多重继承（A类继承B类，B类继承C类），这是java继承区别于C++继承的一个特性。</li>
<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。</li>
</ul>
<h2 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h2><p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。</p>
<h3 id="extends关键字"><a href="#extends关键字" class="headerlink" title="extends关键字"></a>extends关键字</h3><p>extends 只能继承一个类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> String name;   </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String myName, String myid)</span> </span>&#123; </div><div class="line">        <span class="comment">//初始化属性值</span></div><div class="line">    &#125; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  <span class="comment">//吃东西方法的具体实现  &#125; </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123; <span class="comment">//睡觉方法的具体实现  &#125; </span></div><div class="line">&#125; </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Penguin</span>  <span class="keyword">extends</span>  <span class="title">Animal</span></span>&#123; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="implements关键字"><a href="#implements关键字" class="headerlink" title="implements关键字"></a>implements关键字</h3><p>implements可同时继承多个接口（接口跟接口之间采用逗号分隔）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//接口类A</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//接口类B</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//继承接口A与B的实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super 表示使用它的类的父类。super 可用于：</p>
<ul>
<li>调用父类的构造方法；</li>
<li>调用父类的方法（子类覆盖了父类的方法时）；</li>
<li>访问父类的数据域（可以这样用但没有必要这样用）。</li>
</ul>
<p>调用父类的构造方法语法：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">super()<span class="comment">;</span></div><div class="line"></div><div class="line">super(参数列表)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>super 语句必须是子类构造方法的第一条语句。</li>
<li>不能在子类中使用父类构造方法名来调用父类构造方法。</li>
<li>父类的构造方法不被子类继承。</li>
<li>调用父类的构造方法的唯一途径是使用 super 关键字，如果子类中没显式调用，则编译器自动将 super() 作为子类构造方法的第一条语句。这会形成一个构造方法链。</li>
<li>静态方法中不能使用 super 关键字。</li>
</ul>
<p>调用父类的方法语法：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">super.方法名(参数列表)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>如果是继承的方法，是没有必要使用 super 来调用，直接即可调用。但如果子类覆盖或重写了父类的方法，则只有使用 super 才能在子类中调用父类中的被重写的方法。</p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>this 关键字表示当前对象。可用于：</p>
<ul>
<li>调用当前类的构造方法，并且必须是方法的第一条语句。如：<code>this();</code> 调用默认构造方法。<code>this(参数);</code> 调用带参构造方法。</li>
<li>限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 <code>this.num = num;</code>。this.num 表示当前对象的数据域变量 num，而 num 表示方法中的局部变量。</li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写；实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。<br>被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;<span class="comment">//类体&#125;</span></div><div class="line"></div><div class="line">修饰符(<span class="keyword">public</span>/<span class="keyword">private</span>/<span class="keyword">default</span>/<span class="keyword">protected</span>) <span class="keyword">final</span> 返回值类型 方法名()&#123;<span class="comment">//方法体&#125;</span></div><div class="line"></div><div class="line">修饰符(<span class="keyword">public</span>/<span class="keyword">private</span>/<span class="keyword">default</span>/<span class="keyword">protected</span>) <span class="keyword">final</span> 变量类型 变量名 = 值;</div></pre></td></tr></table></figure></p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>子类不能继承父类的构造器，但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。</p>
<p>如果父类有<strong>无参构造器</strong>，没有使用super关键字，系统会自动调用父类的无参构造器。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">SuperClass</span> &#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</div><div class="line">  SuperClass()&#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"SuperClass()"</span>);</div><div class="line">  &#125;</div><div class="line">  SuperClass(<span class="keyword">int</span> n) &#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"SuperClass(int n)"</span>);</div><div class="line">    <span class="keyword">this</span>.n = n;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="title">extends</span> <span class="title">SuperClass</span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</div><div class="line">  </div><div class="line">  SubClass()&#123;</div><div class="line">    super(<span class="number">300</span>);</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"SubClass"</span>);</div><div class="line">  &#125;  </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span>(<span class="params"><span class="keyword">int</span> n</span>)</span>&#123;</div><div class="line">    System.<span class="keyword">out</span>.println(<span class="string">"SubClass(int n):"</span>+n);</div><div class="line">    <span class="keyword">this</span>.n = n;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestSuperSub</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> (<span class="params">String args[]</span>)</span>&#123;</div><div class="line">    SubClass sc = <span class="keyword">new</span> SubClass();</div><div class="line">    SubClass sc2 = <span class="keyword">new</span> SubClass(<span class="number">200</span>); </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">SuperClass</span><span class="params">(int n)</span></span></div><div class="line">SubClass</div><div class="line"><span class="function"><span class="title">SuperClass</span><span class="params">()</span></span></div><div class="line"><span class="function"><span class="title">SubClass</span><span class="params">(int n)</span></span>:<span class="number">200</span></div></pre></td></tr></table></figure></p>
<h1 id="Java-多态"><a href="#Java-多态" class="headerlink" title="Java 多态"></a>Java 多态</h1><p>多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作。同一个事件发生在不同的对象上会产生不同的结果。</p>
<h2 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h2><ol>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ol>
<h2 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h2><ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Parent p</span> = new Child();</div></pre></td></tr></table></figure>
<p>讲到重写时会详细说明。</p>
<h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><p>当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。<br>要想调用父类中被重写的方法，则必须使用关键字super。</p>
<p>例子解析</p>
<ul>
<li>实例中，实例化了两个 Salary 对象：一个使用 Salary 引用 s，另一个使用 Employee 引用 e。</li>
<li>当调用 s.mailCheck() 时，编译器在编译时会在 Salary 类中找到 mailCheck()，执行过程 JVM 就调用 Salary 类的 mailCheck()。</li>
<li>因为 e 是 Employee 的引用，所以调用 e 的 mailCheck() 方法时，编译器会去 Employee 类查找 mailCheck() 方法 。</li>
<li>在编译的时候，编译器使用 Employee 类中的 mailCheck() 方法验证该语句， 但是在<strong>运行的时候</strong>，Java虚拟机(JVM)调用的是 Salary 类中的 mailCheck() 方法。</li>
</ul>
<p>以上整个过程被称为虚拟方法调用，该方法被称为虚拟方法。重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。</p>
<h2 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h2><ul>
<li>方式一：重写</li>
<li>方式二：接口</li>
<li>方式三：抽象类和抽象方法</li>
</ul>
<h1 id="Java-重写与重载"><a href="#Java-重写与重载" class="headerlink" title="Java 重写与重载"></a>Java 重写与重载</h1><h2 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h2><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<br>重写的好处在于子类可以根据需要，定义特定于自己的行为。<br>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。</p>
<p>在编译阶段，只是检查参数的引用类型。然而在运行时，Java虚拟机(JVM)指定对象的类型并且运行该对象的方法。<br>因此在下面的例子中，b.move()之所以能编译成功，是因为Animal类中存在move方法，所以编译成功，然而运行时，运行的是特定对象的方法，即运行的是Dog类的move方法。<br>而对Dog c而言，编译阶段首先是去Dog中查找bark()，因此能编译成功，同时也能运行成功。但是对于b.bark()而言，首先是去Animal类中寻找bark()，因为找不到，因而编译错误。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      System.<span class="keyword">out</span>.println(<span class="string">"动物可以移动"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      System.<span class="keyword">out</span>.println(<span class="string">"测试"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">extends</span> <span class="title">Animal</span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      System.<span class="keyword">out</span>.println(<span class="string">"狗可以跑和走"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      System.<span class="keyword">out</span>.println(<span class="string">"狗可以吠叫"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDog</span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span>&#123;</div><div class="line">      Animal a = <span class="keyword">new</span> Animal(); <span class="comment">// Animal 对象</span></div><div class="line">      Animal b = <span class="keyword">new</span> Dog(); <span class="comment">// Dog 对象</span></div><div class="line"> </div><div class="line">      a.move();<span class="comment">// 执行 Animal 类的方法</span></div><div class="line">      b.move();<span class="comment">// 执行 Dog 类的方法</span></div><div class="line">	  b.test();<span class="comment">// 执行 Animal 类的方法ss</span></div><div class="line">      b.bark();<span class="comment">// 编译错误</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Animal a=<span class="keyword">new</span> <span class="type">Dog</span>()</div></pre></td></tr></table></figure></p>
<p>实际是先实例化一个子类对象，然后在转换为父类对象。先调用父类构造函数，再调用子类构造函数。</p>
<ul>
<li>当子类重写了父类的方法时，将调用子类方法。</li>
<li>子类没有重写父类方法时，将调用父类方法。</li>
<li>调用子类特有方法时，编译错误。</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Animal b</span>=new Animal();</div></pre></td></tr></table></figure>
<p>调用的都是父类的方法</p>
<h2 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h2><ul>
<li>参数列表必须完全与被重写方法的相同；</li>
<li>返回类型必须完全与被重写方法的返回类型相同；</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为final的方法不能被重写。</li>
<li>声明为static的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
</ul>
<h2 id="Super关键字的使用"><a href="#Super关键字的使用" class="headerlink" title="Super关键字的使用"></a>Super关键字的使用</h2><p>当需要在子类中调用父类的被重写方法时，要使用super关键字。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">super</span>.move();<span class="regexp">//</span>调用父类方法，如果没被重写则没必要用<span class="keyword">super</span></div></pre></td></tr></table></figure></p>
<h2 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h2><p>重载(overloading) 是在一个类里面，方法名字相同，而<strong>参数不同</strong>。返回类型可以相同也可以不同。</p>
<h2 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则"></a>重载规则</h2><ul>
<li>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Overloading</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"test1"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"><span class="keyword">int</span> a</span>)</span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"test2"</span>);</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    <span class="comment">//以下两个参数类型顺序不同</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span>(<span class="params"><span class="keyword">int</span> a,String s</span>)</span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"test3"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"returntest3"</span>;</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span>(<span class="params">String s,<span class="keyword">int</span> a</span>)</span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"test4"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"returntest4"</span>;</div><div class="line">    &#125;   </div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</div><div class="line">        Overloading o = <span class="keyword">new</span> Overloading();</div><div class="line">        System.<span class="keyword">out</span>.println(o.test());</div><div class="line">        o.test(<span class="number">1</span>);</div><div class="line">        System.<span class="keyword">out</span>.println(o.test(<span class="number">1</span>,<span class="string">"test3"</span>));</div><div class="line">        System.<span class="keyword">out</span>.println(o.test(<span class="string">"test4"</span>,<span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>方法的重写和重载是java多态性的不同表现。</p>
<ul>
<li>重写是父类与子类之间多态性的一种表现。</li>
<li>重载可以理解成多态的具体表现形式。</li>
</ul>
<h1 id="Java-抽象类"><a href="#Java-抽象类" class="headerlink" title="Java 抽象类"></a>Java 抽象类</h1><p>并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。<br>抽象类除了<strong>不能实例化对象</strong>之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。<br>抽象类必须被继承，才能被使用。<br>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。<br>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在Java语言中使用abstract class来定义抽象类。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public abstract class Employee</div><div class="line">&#123;</div><div class="line">   private String name;</div><div class="line">   private String address;</div><div class="line">   private int number;</div><div class="line">   <span class="built_in">..</span>.</div></pre></td></tr></table></figure></p>
<p>跟一般的类没什么不同，但是编译AbstractDemo类时，会产生错误。</p>
<h2 id="继承抽象类"><a href="#继承抽象类" class="headerlink" title="继承抽象类"></a>继承抽象类</h2><p>通过一般的方法继承Employee类<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="keyword">private</span> double salary; <span class="comment">//Annual salary</span></div><div class="line">   public <span class="type">Salary</span>(<span class="type">String</span> name, <span class="type">String</span> address, int number, double</div><div class="line">      salary)</div><div class="line">   &#123;</div><div class="line">       <span class="keyword">super</span>(name, address, number);</div><div class="line">       setSalary(salary);</div><div class="line">   &#125;</div><div class="line">   ...</div></pre></td></tr></table></figure></p>
<h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">double</span> <span class="title">computePay</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>如果一个类包含抽象方法，那么该类必须是抽象类。</li>
<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li>
</ul>
<p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="keyword">private</span> double salary; <span class="comment">// Annual salary</span></div><div class="line">  </div><div class="line">   public double computePay()&#123;</div><div class="line">      <span class="type">System</span>.out.println(<span class="string">"Computing salary pay for "</span> + getName());</div><div class="line">      <span class="keyword">return</span> salary/<span class="number">52</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="comment">//其余代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="抽象类总结规定"><a href="#抽象类总结规定" class="headerlink" title="抽象类总结规定"></a>抽象类总结规定</h2><ol>
<li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>构造方法，类方法（用static修饰的方法）不能声明为抽象方法。</li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
</ol>
<h1 id="Java-接口"><a href="#Java-接口" class="headerlink" title="Java 接口"></a>Java 接口</h1><p>接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>类描述对象的属性和方法。接口则包含类要实现的方法。<br>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。<br>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。<br>接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<h3 id="接口与类相似点"><a href="#接口与类相似点" class="headerlink" title="接口与类相似点"></a>接口与类相似点</h3><ul>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li>
<li>接口的字节码文件保存在 .class 结尾的文件中。</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ul>
<h3 id="接口与类的区别"><a href="#接口与类的区别" class="headerlink" title="接口与类的区别"></a>接口与类的区别</h3><ul>
<li>接口不能用于实例化对象。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
</ul>
<h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul>
<li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li>
</ul>
<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ol>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ol>
<h2 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h2><p>语法格式如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[可见度] <span class="class"><span class="keyword">interface</span> 接口名称 [<span class="keyword">extends</span> 其他的类名] </span>&#123;</div><div class="line">        <span class="comment">// 声明变量</span></div><div class="line">        <span class="comment">// 抽象方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta"><span class="meta-keyword">import</span> java.lang.*;</span></div><div class="line"><span class="comment">//引入包</span></div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NameOfInterface</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="comment">//任何类型 final, static 字段</span></div><div class="line">   <span class="comment">//抽象方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">   <span class="keyword">public</span> <span class="keyword">void</span> eat();</div><div class="line">   <span class="keyword">public</span> <span class="keyword">void</span> travel();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MammalInt</span> <span class="title">implements</span> <span class="title">Animal</span>&#123;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      System.<span class="keyword">out</span>.println(<span class="string">"Mammal eats"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      System.<span class="keyword">out</span>.println(<span class="string">"Mammal travels"</span>);</div><div class="line">   &#125; </div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">noOfLegs</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String args[]</span>)</span>&#123;</div><div class="line">      MammalInt m = <span class="keyword">new</span> MammalInt();</div><div class="line">      m.eat();</div><div class="line">      m.travel();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Mammal eats</div><div class="line">Mammal travels</div></pre></td></tr></table></figure></p>
<p>重写接口中声明的方法时，需要注意以下规则：</p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li>
<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li>
</ul>
<p>在实现接口的时候，也要注意一些规则：</p>
<ul>
<li>一个类可以同时实现多个接口。</li>
<li>一个类只能继承一个类，但是能实现多个接口。</li>
<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>
</ul>
<h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p>接口的继承使用extends关键字，子接口继承父接口的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 文件名: Sports.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sports</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHomeTeam</span><span class="params">(String name)</span></span>;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisitingTeam</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 文件名: Football.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Sports</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfQuarter</span><span class="params">(<span class="keyword">int</span> quarter)</span></span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 文件名: Hockey.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hockey</span> <span class="keyword">extends</span> <span class="title">Sports</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeGoalScored</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingGoalScored</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfPeriod</span><span class="params">(<span class="keyword">int</span> period)</span></span>;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overtimePeriod</span><span class="params">(<span class="keyword">int</span> ot)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。</p>
<h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>在Java中，类的多继承是不合法，但接口允许多继承。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>Hockey extends Sports, Event</div></pre></td></tr></table></figure></p>
<h2 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h2><p>最常用的继承接口是没有包含任何方法的接口。<br>标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。<br>标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。<br>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">package java.util;</div><div class="line">public<span class="built_in"> interface </span>EventListener&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>
<ul>
<li>建立一个公共的父接口：<br>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</li>
<li>向一个类添加数据类型：<br>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</li>
</ul>
<h1 id="Java-包"><a href="#Java-包" class="headerlink" title="Java 包"></a>Java 包</h1><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。</p>
<h2 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h2><ol>
<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>
<li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>
<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ol>
<p>例如,一个Something.java 文件它的内容<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.java.util</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span>&#123;</span></div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么它的路径应该是 net/java/util/Something.java 这样保存的。 </p>
<p>以下是一些 Java 中的包：</p>
<ul>
<li>java.lang-打包基础的类</li>
<li>java.io-包含输入输出功能的函数</li>
</ul>
<p>开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。</p>
<h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p>每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。</p>
<p>在 animals 包中加入一个接口（interface）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 文件名: Animal.java */</span></div><div class="line"><span class="keyword">package</span> animals;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来，在同一个包中加入该接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> animals;</div><div class="line"> </div><div class="line"><span class="comment">/* 文件名 : MammalInt.java */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MammalInt</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"Mammal eats"</span>);</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"Mammal travels"</span>);</div><div class="line">   &#125; </div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">noOfLegs</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">      MammalInt m = <span class="keyword">new</span> MammalInt();</div><div class="line">      m.eat();</div><div class="line">      m.travel();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，编译这两个文件，并把他们放在一个叫做animals的子目录中。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> mkdir animals</span></div><div class="line"><span class="meta">$</span><span class="bash"> cp Animal.class  MammalInt.class animals</span></div><div class="line"><span class="meta">$</span><span class="bash"> java animals/MammalInt</span></div><div class="line">Mammal eats</div><div class="line">Mammal travel</div></pre></td></tr></table></figure></p>
<h2 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h2><p>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。</p>
<p>语法格式为<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">package</span><span class="number">1</span>[.<span class="keyword">package</span><span class="number">2</span>…].(classname|*);</div></pre></td></tr></table></figure></p>
<p>如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。</p>
<p>下面的 payroll 包已经包含了 Employee 类，接下来向 payroll 包中添加一个 Boss 类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> payroll;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payEmployee</span><span class="params">(Employee e)</span></span></div><div class="line"><span class="function">   </span>&#123;</div><div class="line">      e.mailCheck();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 Boss 类不在 payroll 包中又会怎样？Boss 类必须使用下面几种方法之一来引用其他包中的类。</p>
<ul>
<li>使用类全名描述，<code>payroll.Employee</code></li>
<li>用 import 关键字引入，使用通配符 “<em>“，`import payroll.</em>;`</li>
<li>使用 import 关键字引入 Employee 类，<code>import payroll.Employee;</code></li>
</ul>
<h2 id="package-的目录结构"><a href="#package-的目录结构" class="headerlink" title="package 的目录结构"></a>package 的目录结构</h2><p>类放在包中会有两种主要的结果：</p>
<ul>
<li>包名成为类名的一部分，正如我们前面讨论的一样。</li>
<li>包名必须与相应的字节码所在的目录结构相吻合。</li>
</ul>
<p>通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。</p>
<p>例如：有一个 com.runoob.test 的包，这个包包含一个叫做 Runoob.java 的源文件。<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">....<span class="symbol">\c</span>om<span class="symbol">\r</span>unoob<span class="symbol">\t</span>est<span class="symbol">\R</span>unoob.java</div></pre></td></tr></table></figure></p>
<p>编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 文件名: Runoob.java</span></div><div class="line"><span class="keyword">package</span> com.runoob.test;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runoob</span> &#123;</span></div><div class="line">      </div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Google</span> &#123;</span></div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用-d选项来编译这个文件<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">$javac</span> -d . Runoob.java</span></div></pre></td></tr></table></figure></p>
<p>结果像下面这样放置编译了的文件<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.<span class="symbol">\c</span>om<span class="symbol">\r</span>unoob<span class="symbol">\t</span>est<span class="symbol">\R</span>unoob.class</div><div class="line">.<span class="symbol">\c</span>om<span class="symbol">\r</span>unoob<span class="symbol">\t</span>est<span class="symbol">\G</span>oogle.class</div></pre></td></tr></table></figure></p>
<p>你可以像下面这样来导入所有 \com\runoob\test\ 中定义的类、接口等<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta"><span class="meta-keyword">import</span> com.runoob.test.*;</span></div></pre></td></tr></table></figure></p>
<p>编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;path-one&gt;<span class="symbol">\s</span>ources<span class="symbol">\c</span>om<span class="symbol">\r</span>unoob<span class="symbol">\t</span>est<span class="symbol">\R</span>unoob.java</div><div class="line">&lt;path-two&gt;<span class="symbol">\c</span>lasses<span class="symbol">\c</span>om<span class="symbol">\r</span>unoob<span class="symbol">\t</span>est<span class="symbol">\G</span>oogle.class</div></pre></td></tr></table></figure></p>
<p>这样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。</p>
<p>类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。</p>
<p>一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。</p>
<h2 id="设置-CLASSPATH-系统变量"><a href="#设置-CLASSPATH-系统变量" class="headerlink" title="设置 CLASSPATH 系统变量"></a>设置 CLASSPATH 系统变量</h2><p>用下面的命令显示当前的CLASSPATH变量：</p>
<ul>
<li>Windows 平台（DOS 命令行下）：C:> set CLASSPATH</li>
<li>UNIX 平台（Bourne shell 下）：# echo $CLASSPATH</li>
</ul>
<p>删除当前CLASSPATH变量内容：</p>
<ul>
<li>Windows 平台（DOS 命令行下）：C:> set CLASSPATH=</li>
<li>UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH</li>
</ul>
<p>设置CLASSPATH变量:</p>
<ul>
<li>Windows 平台（DOS 命令行下）： C:> set CLASSPATH=C:\users\jack\java\classes</li>
<li>UNIX 平台（Bourne shell 下）：# CLASSPATH=/home/jack/java/classes; export CLASSPATH</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/07/ssh天猫整站后台结构/" rel="next" title="ssh天猫整站后台结构">
                <i class="fa fa-chevron-left"></i> ssh天猫整站后台结构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/20/Java多线程/" rel="prev" title="java 多线程">
                java 多线程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="徐宏亮" />
          <p class="site-author-name" itemprop="name">徐宏亮</p>
           
              <p class="site-description motion-element" itemprop="description">我要用尽所有的力气才能书写一个词，放弃。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xuhongliang1996" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-封装"><span class="nav-number">1.</span> <span class="nav-text">Java 封装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#封装的优点"><span class="nav-number">1.1.</span> <span class="nav-text">封装的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现Java封装的步骤"><span class="nav-number">1.2.</span> <span class="nav-text">实现Java封装的步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例"><span class="nav-number">1.3.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-继承"><span class="nav-number">2.</span> <span class="nav-text">Java 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#继承的概念"><span class="nav-number">2.1.</span> <span class="nav-text">继承的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生活中的继承"><span class="nav-number">2.1.1.</span> <span class="nav-text">生活中的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的继承格式"><span class="nav-number">2.1.2.</span> <span class="nav-text">类的继承格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么需要继承"><span class="nav-number">2.1.3.</span> <span class="nav-text">为什么需要继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承的特性"><span class="nav-number">2.2.</span> <span class="nav-text">继承的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承关键字"><span class="nav-number">2.3.</span> <span class="nav-text">继承关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#extends关键字"><span class="nav-number">2.3.1.</span> <span class="nav-text">extends关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#implements关键字"><span class="nav-number">2.3.2.</span> <span class="nav-text">implements关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super关键字"><span class="nav-number">2.3.3.</span> <span class="nav-text">super关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this关键字"><span class="nav-number">2.3.4.</span> <span class="nav-text">this关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final关键字"><span class="nav-number">2.3.5.</span> <span class="nav-text">final关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造器"><span class="nav-number">2.4.</span> <span class="nav-text">构造器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-多态"><span class="nav-number">3.</span> <span class="nav-text">Java 多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多态的优点"><span class="nav-number">3.1.</span> <span class="nav-text">多态的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态存在的三个必要条件"><span class="nav-number">3.2.</span> <span class="nav-text">多态存在的三个必要条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚方法"><span class="nav-number">3.3.</span> <span class="nav-text">虚方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态的实现方式"><span class="nav-number">3.4.</span> <span class="nav-text">多态的实现方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-重写与重载"><span class="nav-number">4.</span> <span class="nav-text">Java 重写与重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重写-Override"><span class="nav-number">4.1.</span> <span class="nav-text">重写(Override)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法的重写规则"><span class="nav-number">4.2.</span> <span class="nav-text">方法的重写规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Super关键字的使用"><span class="nav-number">4.3.</span> <span class="nav-text">Super关键字的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载-Overload"><span class="nav-number">4.4.</span> <span class="nav-text">重载(Overload)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载规则"><span class="nav-number">4.5.</span> <span class="nav-text">重载规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-抽象类"><span class="nav-number">5.</span> <span class="nav-text">Java 抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象类"><span class="nav-number">5.1.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承抽象类"><span class="nav-number">5.2.</span> <span class="nav-text">继承抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象方法"><span class="nav-number">5.3.</span> <span class="nav-text">抽象方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象类总结规定"><span class="nav-number">5.4.</span> <span class="nav-text">抽象类总结规定</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-接口"><span class="nav-number">6.</span> <span class="nav-text">Java 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#接口"><span class="nav-number">6.1.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#接口与类相似点"><span class="nav-number">6.1.1.</span> <span class="nav-text">接口与类相似点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口与类的区别"><span class="nav-number">6.1.2.</span> <span class="nav-text">接口与类的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口特性"><span class="nav-number">6.1.3.</span> <span class="nav-text">接口特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类和接口的区别"><span class="nav-number">6.1.4.</span> <span class="nav-text">抽象类和接口的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口的声明"><span class="nav-number">6.2.</span> <span class="nav-text">接口的声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口的实现"><span class="nav-number">6.3.</span> <span class="nav-text">接口的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口的继承"><span class="nav-number">6.4.</span> <span class="nav-text">接口的继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口的多继承"><span class="nav-number">6.5.</span> <span class="nav-text">接口的多继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标记接口"><span class="nav-number">6.6.</span> <span class="nav-text">标记接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-包"><span class="nav-number">7.</span> <span class="nav-text">Java 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#包的作用"><span class="nav-number">7.1.</span> <span class="nav-text">包的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建包"><span class="nav-number">7.2.</span> <span class="nav-text">创建包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#import-关键字"><span class="nav-number">7.3.</span> <span class="nav-text">import 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#package-的目录结构"><span class="nav-number">7.4.</span> <span class="nav-text">package 的目录结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置-CLASSPATH-系统变量"><span class="nav-number">7.5.</span> <span class="nav-text">设置 CLASSPATH 系统变量</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">徐宏亮</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.1"></script>



  

  

  

  

  

  

</body>
</html>
